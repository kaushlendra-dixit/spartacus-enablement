import { ElementRef, OnDestroy, Renderer2 } from '@angular/core';
import { Router } from '@angular/router';
import { ICON_TYPE } from '../../misc/icon/index';
import { NavigationNode } from './navigation-node.model';
import * as ɵngcc0 from '@angular/core';
export declare class NavigationUIComponent implements OnDestroy {
    private router;
    private renderer;
    private elemRef;
    /**
     * The navigation node to render.
     */
    node: NavigationNode;
    /**
     * The number of child nodes that must be wrapped.
     */
    wrapAfter: number;
    /**
     * the icon type that will be used for navigation nodes
     * with children.
     */
    iconType: typeof ICON_TYPE;
    /**
     * Indicates whether the navigation should support flyout.
     * If flyout is set to true, the
     * nested child navigation nodes will only appear on hover or focus.
     */
    flyout: boolean;
    isOpen: boolean;
    private openNodes;
    private subscriptions;
    private resize;
    onResize(): void;
    constructor(router: Router, renderer: Renderer2, elemRef: ElementRef);
    toggleOpen(event: UIEvent): void;
    back(): void;
    clear(): void;
    onMouseEnter(event: MouseEvent): void;
    getTotalDepth(node: NavigationNode, depth?: number): number;
    getColumnCount(length: number): number;
    focusAfterPreviousClicked(event: MouseEvent): Document;
    ngOnDestroy(): void;
    private alignWrapperToRightIfStickOut;
    private alignWrappersToRightIfStickOut;
    private updateClasses;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<NavigationUIComponent, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDefWithMeta<NavigationUIComponent, "cx-navigation-ui", never, { "flyout": "flyout"; "isOpen": "isOpen"; "node": "node"; "wrapAfter": "wrapAfter"; }, {}, never, never>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmF2aWdhdGlvbi11aS5jb21wb25lbnQuZC50cyIsInNvdXJjZXMiOlsibmF2aWdhdGlvbi11aS5jb21wb25lbnQuZC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBFbGVtZW50UmVmLCBPbkRlc3Ryb3ksIFJlbmRlcmVyMiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBSb3V0ZXIgfSBmcm9tICdAYW5ndWxhci9yb3V0ZXInO1xyXG5pbXBvcnQgeyBJQ09OX1RZUEUgfSBmcm9tICcuLi8uLi9taXNjL2ljb24vaW5kZXgnO1xyXG5pbXBvcnQgeyBOYXZpZ2F0aW9uTm9kZSB9IGZyb20gJy4vbmF2aWdhdGlvbi1ub2RlLm1vZGVsJztcclxuZXhwb3J0IGRlY2xhcmUgY2xhc3MgTmF2aWdhdGlvblVJQ29tcG9uZW50IGltcGxlbWVudHMgT25EZXN0cm95IHtcclxuICAgIHByaXZhdGUgcm91dGVyO1xyXG4gICAgcHJpdmF0ZSByZW5kZXJlcjtcclxuICAgIHByaXZhdGUgZWxlbVJlZjtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIG5hdmlnYXRpb24gbm9kZSB0byByZW5kZXIuXHJcbiAgICAgKi9cclxuICAgIG5vZGU6IE5hdmlnYXRpb25Ob2RlO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgbnVtYmVyIG9mIGNoaWxkIG5vZGVzIHRoYXQgbXVzdCBiZSB3cmFwcGVkLlxyXG4gICAgICovXHJcbiAgICB3cmFwQWZ0ZXI6IG51bWJlcjtcclxuICAgIC8qKlxyXG4gICAgICogdGhlIGljb24gdHlwZSB0aGF0IHdpbGwgYmUgdXNlZCBmb3IgbmF2aWdhdGlvbiBub2Rlc1xyXG4gICAgICogd2l0aCBjaGlsZHJlbi5cclxuICAgICAqL1xyXG4gICAgaWNvblR5cGU6IHR5cGVvZiBJQ09OX1RZUEU7XHJcbiAgICAvKipcclxuICAgICAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSBuYXZpZ2F0aW9uIHNob3VsZCBzdXBwb3J0IGZseW91dC5cclxuICAgICAqIElmIGZseW91dCBpcyBzZXQgdG8gdHJ1ZSwgdGhlXHJcbiAgICAgKiBuZXN0ZWQgY2hpbGQgbmF2aWdhdGlvbiBub2RlcyB3aWxsIG9ubHkgYXBwZWFyIG9uIGhvdmVyIG9yIGZvY3VzLlxyXG4gICAgICovXHJcbiAgICBmbHlvdXQ6IGJvb2xlYW47XHJcbiAgICBpc09wZW46IGJvb2xlYW47XHJcbiAgICBwcml2YXRlIG9wZW5Ob2RlcztcclxuICAgIHByaXZhdGUgc3Vic2NyaXB0aW9ucztcclxuICAgIHByaXZhdGUgcmVzaXplO1xyXG4gICAgb25SZXNpemUoKTogdm9pZDtcclxuICAgIGNvbnN0cnVjdG9yKHJvdXRlcjogUm91dGVyLCByZW5kZXJlcjogUmVuZGVyZXIyLCBlbGVtUmVmOiBFbGVtZW50UmVmKTtcclxuICAgIHRvZ2dsZU9wZW4oZXZlbnQ6IFVJRXZlbnQpOiB2b2lkO1xyXG4gICAgYmFjaygpOiB2b2lkO1xyXG4gICAgY2xlYXIoKTogdm9pZDtcclxuICAgIG9uTW91c2VFbnRlcihldmVudDogTW91c2VFdmVudCk6IHZvaWQ7XHJcbiAgICBnZXRUb3RhbERlcHRoKG5vZGU6IE5hdmlnYXRpb25Ob2RlLCBkZXB0aD86IG51bWJlcik6IG51bWJlcjtcclxuICAgIGdldENvbHVtbkNvdW50KGxlbmd0aDogbnVtYmVyKTogbnVtYmVyO1xyXG4gICAgZm9jdXNBZnRlclByZXZpb3VzQ2xpY2tlZChldmVudDogTW91c2VFdmVudCk6IERvY3VtZW50O1xyXG4gICAgbmdPbkRlc3Ryb3koKTogdm9pZDtcclxuICAgIHByaXZhdGUgYWxpZ25XcmFwcGVyVG9SaWdodElmU3RpY2tPdXQ7XHJcbiAgICBwcml2YXRlIGFsaWduV3JhcHBlcnNUb1JpZ2h0SWZTdGlja091dDtcclxuICAgIHByaXZhdGUgdXBkYXRlQ2xhc3NlcztcclxufVxyXG4iXX0=