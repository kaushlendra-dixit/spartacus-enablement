import { AutoFocusConfig } from '../keyboard-focus.model';
import * as ɵngcc0 from '@angular/core';
export declare class SelectFocusUtility {
    /**
     * Query selectors used to query focusable child elements of the host element.
     * The selectors are supplemented with `:not([disabled])` and `:not([hidden])`.
     */
    protected focusableSelectors: string[];
    protected focusableSelectorSuffix: string;
    query(host: HTMLElement, selector: string): HTMLElement[];
    findFirstFocusable(host: HTMLElement, config?: AutoFocusConfig): HTMLElement;
    /**
     * returns all focusable child elements of the host element. The element selectors
     * are build from the `focusableSelectors`.
     *
     * @param host the `HTMLElement` used to query focusable elements
     * @param locked indicates whether inactive (`tabindex="-1"`) focusable elements should be returned
     * @param invisible indicates whether hidden focusable elements should be returned
     */
    findFocusable(host: HTMLElement, locked?: boolean, invisible?: boolean): HTMLElement[];
    /**
     * Indicates whether the element is hidden by CSS. There are various CSS rules and
     * HTML structures which can lead to an hidden or invisible element. An `offsetParent`
     * of null indicates that the element or any of it's decendants is hidden (`display:none`).
     *
     * Oother techniques use the visibility (`visibility: hidden`), opacity (`opacity`) or
     * phyisical location on the element itself or any of it's anchestor elements. Those
     * technique require to work with the _computed styles_, which will cause a performance
     * downgrade. We don't do this in the standard implementaton.
     */
    protected isHidden(el: HTMLElement): boolean;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<SelectFocusUtility, never>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2VsZWN0LWZvY3VzLnV0aWwuZC50cyIsInNvdXJjZXMiOlsic2VsZWN0LWZvY3VzLnV0aWwuZC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQXV0b0ZvY3VzQ29uZmlnIH0gZnJvbSAnLi4va2V5Ym9hcmQtZm9jdXMubW9kZWwnO1xyXG5leHBvcnQgZGVjbGFyZSBjbGFzcyBTZWxlY3RGb2N1c1V0aWxpdHkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBRdWVyeSBzZWxlY3RvcnMgdXNlZCB0byBxdWVyeSBmb2N1c2FibGUgY2hpbGQgZWxlbWVudHMgb2YgdGhlIGhvc3QgZWxlbWVudC5cclxuICAgICAqIFRoZSBzZWxlY3RvcnMgYXJlIHN1cHBsZW1lbnRlZCB3aXRoIGA6bm90KFtkaXNhYmxlZF0pYCBhbmQgYDpub3QoW2hpZGRlbl0pYC5cclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIGZvY3VzYWJsZVNlbGVjdG9yczogc3RyaW5nW107XHJcbiAgICBwcm90ZWN0ZWQgZm9jdXNhYmxlU2VsZWN0b3JTdWZmaXg6IHN0cmluZztcclxuICAgIHF1ZXJ5KGhvc3Q6IEhUTUxFbGVtZW50LCBzZWxlY3Rvcjogc3RyaW5nKTogSFRNTEVsZW1lbnRbXTtcclxuICAgIGZpbmRGaXJzdEZvY3VzYWJsZShob3N0OiBIVE1MRWxlbWVudCwgY29uZmlnPzogQXV0b0ZvY3VzQ29uZmlnKTogSFRNTEVsZW1lbnQ7XHJcbiAgICAvKipcclxuICAgICAqIHJldHVybnMgYWxsIGZvY3VzYWJsZSBjaGlsZCBlbGVtZW50cyBvZiB0aGUgaG9zdCBlbGVtZW50LiBUaGUgZWxlbWVudCBzZWxlY3RvcnNcclxuICAgICAqIGFyZSBidWlsZCBmcm9tIHRoZSBgZm9jdXNhYmxlU2VsZWN0b3JzYC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gaG9zdCB0aGUgYEhUTUxFbGVtZW50YCB1c2VkIHRvIHF1ZXJ5IGZvY3VzYWJsZSBlbGVtZW50c1xyXG4gICAgICogQHBhcmFtIGxvY2tlZCBpbmRpY2F0ZXMgd2hldGhlciBpbmFjdGl2ZSAoYHRhYmluZGV4PVwiLTFcImApIGZvY3VzYWJsZSBlbGVtZW50cyBzaG91bGQgYmUgcmV0dXJuZWRcclxuICAgICAqIEBwYXJhbSBpbnZpc2libGUgaW5kaWNhdGVzIHdoZXRoZXIgaGlkZGVuIGZvY3VzYWJsZSBlbGVtZW50cyBzaG91bGQgYmUgcmV0dXJuZWRcclxuICAgICAqL1xyXG4gICAgZmluZEZvY3VzYWJsZShob3N0OiBIVE1MRWxlbWVudCwgbG9ja2VkPzogYm9vbGVhbiwgaW52aXNpYmxlPzogYm9vbGVhbik6IEhUTUxFbGVtZW50W107XHJcbiAgICAvKipcclxuICAgICAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSBlbGVtZW50IGlzIGhpZGRlbiBieSBDU1MuIFRoZXJlIGFyZSB2YXJpb3VzIENTUyBydWxlcyBhbmRcclxuICAgICAqIEhUTUwgc3RydWN0dXJlcyB3aGljaCBjYW4gbGVhZCB0byBhbiBoaWRkZW4gb3IgaW52aXNpYmxlIGVsZW1lbnQuIEFuIGBvZmZzZXRQYXJlbnRgXHJcbiAgICAgKiBvZiBudWxsIGluZGljYXRlcyB0aGF0IHRoZSBlbGVtZW50IG9yIGFueSBvZiBpdCdzIGRlY2VuZGFudHMgaXMgaGlkZGVuIChgZGlzcGxheTpub25lYCkuXHJcbiAgICAgKlxyXG4gICAgICogT290aGVyIHRlY2huaXF1ZXMgdXNlIHRoZSB2aXNpYmlsaXR5IChgdmlzaWJpbGl0eTogaGlkZGVuYCksIG9wYWNpdHkgKGBvcGFjaXR5YCkgb3JcclxuICAgICAqIHBoeWlzaWNhbCBsb2NhdGlvbiBvbiB0aGUgZWxlbWVudCBpdHNlbGYgb3IgYW55IG9mIGl0J3MgYW5jaGVzdG9yIGVsZW1lbnRzLiBUaG9zZVxyXG4gICAgICogdGVjaG5pcXVlIHJlcXVpcmUgdG8gd29yayB3aXRoIHRoZSBfY29tcHV0ZWQgc3R5bGVzXywgd2hpY2ggd2lsbCBjYXVzZSBhIHBlcmZvcm1hbmNlXHJcbiAgICAgKiBkb3duZ3JhZGUuIFdlIGRvbid0IGRvIHRoaXMgaW4gdGhlIHN0YW5kYXJkIGltcGxlbWVudGF0b24uXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBpc0hpZGRlbihlbDogSFRNTEVsZW1lbnQpOiBib29sZWFuO1xyXG59XHJcbiJdfQ==