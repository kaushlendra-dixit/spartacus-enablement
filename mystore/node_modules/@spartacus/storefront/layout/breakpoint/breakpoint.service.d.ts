import { WindowRef } from '@spartacus/core';
import { Observable } from 'rxjs';
import { BREAKPOINT, LayoutConfig } from '../config/layout-config';
import * as ɵngcc0 from '@angular/core';
export declare class BreakpointService {
    private winRef;
    private config;
    constructor(winRef: WindowRef, config: LayoutConfig);
    get breakpoint$(): Observable<BREAKPOINT>;
    /**
     * Returns the _maximum_ size for the breakpint, given by the `LayoutConfig.breakpoints`
     * configuration. If no configuration is available for the given breakpoint, the
     * method will return the default values:
     * - xs: 567
     * - sm: 768
     * - md: 992
     * - lg: 1200
     */
    getSize(breakpoint: BREAKPOINT): number;
    /**
     * Returns all available breakpoints for the system.
     */
    get breakpoints(): BREAKPOINT[];
    /**
     * Indicates whether the current screen size is smaller than the maximum size of the
     * given breakpoint.
     *
     * If the given breakpoint is `BREAKPOINT.md`, the method returns `true` when the
     * window innerWidth is smaller than the configured size of `BREAKPOINT.md`.
     */
    isDown(breakpoint: BREAKPOINT): Observable<boolean>;
    /**
     * Indicates whether the current screen size is larger than the minimum size of the
     * given breakpoint.
     *
     * If the given breakpoint is `BREAKPOINT.md`, the method returns `true` when the
     * window innerWidth is larger than the configured size of `BREAKPOINT.sm`.
     */
    isUp(breakpoint: BREAKPOINT): Observable<boolean>;
    /**
     * Indicates whether the current screen size fits to the given breakpoint
     */
    isEqual(breakpoint: BREAKPOINT): Observable<boolean>;
    protected getBreakpoint(windowWidth: number): BREAKPOINT;
    protected getClosest(windowWidth?: number): BREAKPOINT;
    get window(): Window;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<BreakpointService, never>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYnJlYWtwb2ludC5zZXJ2aWNlLmQudHMiLCJzb3VyY2VzIjpbImJyZWFrcG9pbnQuc2VydmljZS5kLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0EiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBXaW5kb3dSZWYgfSBmcm9tICdAc3BhcnRhY3VzL2NvcmUnO1xyXG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcyc7XHJcbmltcG9ydCB7IEJSRUFLUE9JTlQsIExheW91dENvbmZpZyB9IGZyb20gJy4uL2NvbmZpZy9sYXlvdXQtY29uZmlnJztcclxuZXhwb3J0IGRlY2xhcmUgY2xhc3MgQnJlYWtwb2ludFNlcnZpY2Uge1xyXG4gICAgcHJpdmF0ZSB3aW5SZWY7XHJcbiAgICBwcml2YXRlIGNvbmZpZztcclxuICAgIGNvbnN0cnVjdG9yKHdpblJlZjogV2luZG93UmVmLCBjb25maWc6IExheW91dENvbmZpZyk7XHJcbiAgICBnZXQgYnJlYWtwb2ludCQoKTogT2JzZXJ2YWJsZTxCUkVBS1BPSU5UPjtcclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgX21heGltdW1fIHNpemUgZm9yIHRoZSBicmVha3BpbnQsIGdpdmVuIGJ5IHRoZSBgTGF5b3V0Q29uZmlnLmJyZWFrcG9pbnRzYFxyXG4gICAgICogY29uZmlndXJhdGlvbi4gSWYgbm8gY29uZmlndXJhdGlvbiBpcyBhdmFpbGFibGUgZm9yIHRoZSBnaXZlbiBicmVha3BvaW50LCB0aGVcclxuICAgICAqIG1ldGhvZCB3aWxsIHJldHVybiB0aGUgZGVmYXVsdCB2YWx1ZXM6XHJcbiAgICAgKiAtIHhzOiA1NjdcclxuICAgICAqIC0gc206IDc2OFxyXG4gICAgICogLSBtZDogOTkyXHJcbiAgICAgKiAtIGxnOiAxMjAwXHJcbiAgICAgKi9cclxuICAgIGdldFNpemUoYnJlYWtwb2ludDogQlJFQUtQT0lOVCk6IG51bWJlcjtcclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhbGwgYXZhaWxhYmxlIGJyZWFrcG9pbnRzIGZvciB0aGUgc3lzdGVtLlxyXG4gICAgICovXHJcbiAgICBnZXQgYnJlYWtwb2ludHMoKTogQlJFQUtQT0lOVFtdO1xyXG4gICAgLyoqXHJcbiAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgY3VycmVudCBzY3JlZW4gc2l6ZSBpcyBzbWFsbGVyIHRoYW4gdGhlIG1heGltdW0gc2l6ZSBvZiB0aGVcclxuICAgICAqIGdpdmVuIGJyZWFrcG9pbnQuXHJcbiAgICAgKlxyXG4gICAgICogSWYgdGhlIGdpdmVuIGJyZWFrcG9pbnQgaXMgYEJSRUFLUE9JTlQubWRgLCB0aGUgbWV0aG9kIHJldHVybnMgYHRydWVgIHdoZW4gdGhlXHJcbiAgICAgKiB3aW5kb3cgaW5uZXJXaWR0aCBpcyBzbWFsbGVyIHRoYW4gdGhlIGNvbmZpZ3VyZWQgc2l6ZSBvZiBgQlJFQUtQT0lOVC5tZGAuXHJcbiAgICAgKi9cclxuICAgIGlzRG93bihicmVha3BvaW50OiBCUkVBS1BPSU5UKTogT2JzZXJ2YWJsZTxib29sZWFuPjtcclxuICAgIC8qKlxyXG4gICAgICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGN1cnJlbnQgc2NyZWVuIHNpemUgaXMgbGFyZ2VyIHRoYW4gdGhlIG1pbmltdW0gc2l6ZSBvZiB0aGVcclxuICAgICAqIGdpdmVuIGJyZWFrcG9pbnQuXHJcbiAgICAgKlxyXG4gICAgICogSWYgdGhlIGdpdmVuIGJyZWFrcG9pbnQgaXMgYEJSRUFLUE9JTlQubWRgLCB0aGUgbWV0aG9kIHJldHVybnMgYHRydWVgIHdoZW4gdGhlXHJcbiAgICAgKiB3aW5kb3cgaW5uZXJXaWR0aCBpcyBsYXJnZXIgdGhhbiB0aGUgY29uZmlndXJlZCBzaXplIG9mIGBCUkVBS1BPSU5ULnNtYC5cclxuICAgICAqL1xyXG4gICAgaXNVcChicmVha3BvaW50OiBCUkVBS1BPSU5UKTogT2JzZXJ2YWJsZTxib29sZWFuPjtcclxuICAgIC8qKlxyXG4gICAgICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGN1cnJlbnQgc2NyZWVuIHNpemUgZml0cyB0byB0aGUgZ2l2ZW4gYnJlYWtwb2ludFxyXG4gICAgICovXHJcbiAgICBpc0VxdWFsKGJyZWFrcG9pbnQ6IEJSRUFLUE9JTlQpOiBPYnNlcnZhYmxlPGJvb2xlYW4+O1xyXG4gICAgcHJvdGVjdGVkIGdldEJyZWFrcG9pbnQod2luZG93V2lkdGg6IG51bWJlcik6IEJSRUFLUE9JTlQ7XHJcbiAgICBwcm90ZWN0ZWQgZ2V0Q2xvc2VzdCh3aW5kb3dXaWR0aD86IG51bWJlcik6IEJSRUFLUE9JTlQ7XHJcbiAgICBnZXQgd2luZG93KCk6IFdpbmRvdztcclxufVxyXG4iXX0=