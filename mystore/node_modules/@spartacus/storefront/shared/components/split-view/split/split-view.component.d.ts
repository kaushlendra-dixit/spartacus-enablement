import { OnDestroy } from '@angular/core';
import { Subscription } from 'rxjs';
import { SplitViewService } from '../split-view.service';
/**
 * The split-view component supports an unlimited number of nested views. The component
 * is a host to those view components and doesn't add any restrictions to it's content;
 * content is projected as-is.
 *
 * ```html
 * <cx-split-view>
 *   <cx-view></cx-view>
 *   <cx-view></cx-view>
 *   <any-wrapper>
 *     <cx-view></cx-view>
 *   </any-wrapper>
 * </cx-split-view>
 * ```
 *
 * The split view component is only concerned with tracking the underlying _visible_
 * view components, so that the `lastVisibleView` can be updated accordingly. The actual
 * visibility of views is controlled by CSS. To allow for maximum flexibility, the CSS
 * implementation is using CSS variables. The `lastVisibleView` is bind to the
 * `--cx-active-view` on the host, so that all descendants views will inherit the
 * property conveniently.
 */
import * as ɵngcc0 from '@angular/core';
export declare class SplitViewComponent implements OnDestroy {
    protected splitService: SplitViewService;
    /**
     * Sets the default hide mode for views. This mode is useful in case views are dynamically being created,
     * for example when they are created by router components.
     */
    set hideMode(mode: boolean);
    /**
     * Indicates the last visible view in the range of views that is visible. This
     * is bind to a css variable `--cx-active-view` so that the experience
     * can be fully controlled by css.
     */
    lastVisibleView: number;
    protected subscription: Subscription;
    constructor(splitService: SplitViewService);
    ngOnDestroy(): void;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<SplitViewComponent, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDefWithMeta<SplitViewComponent, "cx-split-view", never, { "hideMode": "hideMode"; }, {}, never, ["*"]>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3BsaXQtdmlldy5jb21wb25lbnQuZC50cyIsInNvdXJjZXMiOlsic3BsaXQtdmlldy5jb21wb25lbnQuZC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBPbkRlc3Ryb3kgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcyc7XHJcbmltcG9ydCB7IFNwbGl0Vmlld1NlcnZpY2UgfSBmcm9tICcuLi9zcGxpdC12aWV3LnNlcnZpY2UnO1xyXG4vKipcclxuICogVGhlIHNwbGl0LXZpZXcgY29tcG9uZW50IHN1cHBvcnRzIGFuIHVubGltaXRlZCBudW1iZXIgb2YgbmVzdGVkIHZpZXdzLiBUaGUgY29tcG9uZW50XHJcbiAqIGlzIGEgaG9zdCB0byB0aG9zZSB2aWV3IGNvbXBvbmVudHMgYW5kIGRvZXNuJ3QgYWRkIGFueSByZXN0cmljdGlvbnMgdG8gaXQncyBjb250ZW50O1xyXG4gKiBjb250ZW50IGlzIHByb2plY3RlZCBhcy1pcy5cclxuICpcclxuICogYGBgaHRtbFxyXG4gKiA8Y3gtc3BsaXQtdmlldz5cclxuICogICA8Y3gtdmlldz48L2N4LXZpZXc+XHJcbiAqICAgPGN4LXZpZXc+PC9jeC12aWV3PlxyXG4gKiAgIDxhbnktd3JhcHBlcj5cclxuICogICAgIDxjeC12aWV3PjwvY3gtdmlldz5cclxuICogICA8L2FueS13cmFwcGVyPlxyXG4gKiA8L2N4LXNwbGl0LXZpZXc+XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBUaGUgc3BsaXQgdmlldyBjb21wb25lbnQgaXMgb25seSBjb25jZXJuZWQgd2l0aCB0cmFja2luZyB0aGUgdW5kZXJseWluZyBfdmlzaWJsZV9cclxuICogdmlldyBjb21wb25lbnRzLCBzbyB0aGF0IHRoZSBgbGFzdFZpc2libGVWaWV3YCBjYW4gYmUgdXBkYXRlZCBhY2NvcmRpbmdseS4gVGhlIGFjdHVhbFxyXG4gKiB2aXNpYmlsaXR5IG9mIHZpZXdzIGlzIGNvbnRyb2xsZWQgYnkgQ1NTLiBUbyBhbGxvdyBmb3IgbWF4aW11bSBmbGV4aWJpbGl0eSwgdGhlIENTU1xyXG4gKiBpbXBsZW1lbnRhdGlvbiBpcyB1c2luZyBDU1MgdmFyaWFibGVzLiBUaGUgYGxhc3RWaXNpYmxlVmlld2AgaXMgYmluZCB0byB0aGVcclxuICogYC0tY3gtYWN0aXZlLXZpZXdgIG9uIHRoZSBob3N0LCBzbyB0aGF0IGFsbCBkZXNjZW5kYW50cyB2aWV3cyB3aWxsIGluaGVyaXQgdGhlXHJcbiAqIHByb3BlcnR5IGNvbnZlbmllbnRseS5cclxuICovXHJcbmV4cG9ydCBkZWNsYXJlIGNsYXNzIFNwbGl0Vmlld0NvbXBvbmVudCBpbXBsZW1lbnRzIE9uRGVzdHJveSB7XHJcbiAgICBwcm90ZWN0ZWQgc3BsaXRTZXJ2aWNlOiBTcGxpdFZpZXdTZXJ2aWNlO1xyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBkZWZhdWx0IGhpZGUgbW9kZSBmb3Igdmlld3MuIFRoaXMgbW9kZSBpcyB1c2VmdWwgaW4gY2FzZSB2aWV3cyBhcmUgZHluYW1pY2FsbHkgYmVpbmcgY3JlYXRlZCxcclxuICAgICAqIGZvciBleGFtcGxlIHdoZW4gdGhleSBhcmUgY3JlYXRlZCBieSByb3V0ZXIgY29tcG9uZW50cy5cclxuICAgICAqL1xyXG4gICAgc2V0IGhpZGVNb2RlKG1vZGU6IGJvb2xlYW4pO1xyXG4gICAgLyoqXHJcbiAgICAgKiBJbmRpY2F0ZXMgdGhlIGxhc3QgdmlzaWJsZSB2aWV3IGluIHRoZSByYW5nZSBvZiB2aWV3cyB0aGF0IGlzIHZpc2libGUuIFRoaXNcclxuICAgICAqIGlzIGJpbmQgdG8gYSBjc3MgdmFyaWFibGUgYC0tY3gtYWN0aXZlLXZpZXdgIHNvIHRoYXQgdGhlIGV4cGVyaWVuY2VcclxuICAgICAqIGNhbiBiZSBmdWxseSBjb250cm9sbGVkIGJ5IGNzcy5cclxuICAgICAqL1xyXG4gICAgbGFzdFZpc2libGVWaWV3OiBudW1iZXI7XHJcbiAgICBwcm90ZWN0ZWQgc3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb247XHJcbiAgICBjb25zdHJ1Y3RvcihzcGxpdFNlcnZpY2U6IFNwbGl0Vmlld1NlcnZpY2UpO1xyXG4gICAgbmdPbkRlc3Ryb3koKTogdm9pZDtcclxufVxyXG4iXX0=