import { BehaviorSubject } from 'rxjs';
/**
 * Provides support for CONFIG_INITIALIZERS
 */
import * as ɵngcc0 from '@angular/core';
export declare class ConfigInitializerService {
    protected config: any;
    protected initializerGuard: any;
    constructor(config: any, initializerGuard: any);
    protected ongoingScopes$: BehaviorSubject<string[]>;
    /**
     * Returns true if config is stable, i.e. all CONFIG_INITIALIZERS resolved correctly
     */
    get isStable(): boolean;
    /**
     * Recommended way to get config for code that can run before app will finish
     * initialization (APP_INITIALIZERS, selected service constructors)
     *
     * Used without parameters waits for the whole config to become stable
     *
     * Parameters allow to describe which part of the config should be stable using
     * string describing config part, e.g.:
     * 'siteContext', 'siteContext.language', etc.
     *
     * @param scopes String describing parts of the config we want to be sure are stable
     */
    getStableConfig(...scopes: string[]): Promise<any>;
    /**
     * Removes provided scopes from currently ongoingScopes
     *
     * @param scopes
     */
    protected finishScopes(scopes: string[]): void;
    /**
     * Return true if provided scopes are not part of ongoingScopes
     *
     * @param scopes
     * @param ongoingScopes
     */
    protected areReady(scopes: string[], ongoingScopes: string[]): boolean;
    /**
     * Check if two scopes overlap.
     *
     * Example of scopes that overlap:
     * 'test' and 'test', 'test.a' and 'test', 'test' and 'test.a'
     *
     * Example of scopes that do not overlap:
     * 'test' and 'testA', 'test.a' and 'test.b', 'test.nested' and 'test.nest'
     *
     * @param a ScopeA
     * @param b ScopeB
     */
    protected scopesOverlap(a: string, b: string): boolean;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<ConfigInitializerService, [null, { optional: true; }]>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29uZmlnLWluaXRpYWxpemVyLnNlcnZpY2UuZC50cyIsInNvdXJjZXMiOlsiY29uZmlnLWluaXRpYWxpemVyLnNlcnZpY2UuZC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0EiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBCZWhhdmlvclN1YmplY3QgfSBmcm9tICdyeGpzJztcclxuLyoqXHJcbiAqIFByb3ZpZGVzIHN1cHBvcnQgZm9yIENPTkZJR19JTklUSUFMSVpFUlNcclxuICovXHJcbmV4cG9ydCBkZWNsYXJlIGNsYXNzIENvbmZpZ0luaXRpYWxpemVyU2VydmljZSB7XHJcbiAgICBwcm90ZWN0ZWQgY29uZmlnOiBhbnk7XHJcbiAgICBwcm90ZWN0ZWQgaW5pdGlhbGl6ZXJHdWFyZDogYW55O1xyXG4gICAgY29uc3RydWN0b3IoY29uZmlnOiBhbnksIGluaXRpYWxpemVyR3VhcmQ6IGFueSk7XHJcbiAgICBwcm90ZWN0ZWQgb25nb2luZ1Njb3BlcyQ6IEJlaGF2aW9yU3ViamVjdDxzdHJpbmdbXT47XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiBjb25maWcgaXMgc3RhYmxlLCBpLmUuIGFsbCBDT05GSUdfSU5JVElBTElaRVJTIHJlc29sdmVkIGNvcnJlY3RseVxyXG4gICAgICovXHJcbiAgICBnZXQgaXNTdGFibGUoKTogYm9vbGVhbjtcclxuICAgIC8qKlxyXG4gICAgICogUmVjb21tZW5kZWQgd2F5IHRvIGdldCBjb25maWcgZm9yIGNvZGUgdGhhdCBjYW4gcnVuIGJlZm9yZSBhcHAgd2lsbCBmaW5pc2hcclxuICAgICAqIGluaXRpYWxpemF0aW9uIChBUFBfSU5JVElBTElaRVJTLCBzZWxlY3RlZCBzZXJ2aWNlIGNvbnN0cnVjdG9ycylcclxuICAgICAqXHJcbiAgICAgKiBVc2VkIHdpdGhvdXQgcGFyYW1ldGVycyB3YWl0cyBmb3IgdGhlIHdob2xlIGNvbmZpZyB0byBiZWNvbWUgc3RhYmxlXHJcbiAgICAgKlxyXG4gICAgICogUGFyYW1ldGVycyBhbGxvdyB0byBkZXNjcmliZSB3aGljaCBwYXJ0IG9mIHRoZSBjb25maWcgc2hvdWxkIGJlIHN0YWJsZSB1c2luZ1xyXG4gICAgICogc3RyaW5nIGRlc2NyaWJpbmcgY29uZmlnIHBhcnQsIGUuZy46XHJcbiAgICAgKiAnc2l0ZUNvbnRleHQnLCAnc2l0ZUNvbnRleHQubGFuZ3VhZ2UnLCBldGMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHNjb3BlcyBTdHJpbmcgZGVzY3JpYmluZyBwYXJ0cyBvZiB0aGUgY29uZmlnIHdlIHdhbnQgdG8gYmUgc3VyZSBhcmUgc3RhYmxlXHJcbiAgICAgKi9cclxuICAgIGdldFN0YWJsZUNvbmZpZyguLi5zY29wZXM6IHN0cmluZ1tdKTogUHJvbWlzZTxhbnk+O1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIHByb3ZpZGVkIHNjb3BlcyBmcm9tIGN1cnJlbnRseSBvbmdvaW5nU2NvcGVzXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHNjb3Blc1xyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgZmluaXNoU2NvcGVzKHNjb3Blczogc3RyaW5nW10pOiB2b2lkO1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gdHJ1ZSBpZiBwcm92aWRlZCBzY29wZXMgYXJlIG5vdCBwYXJ0IG9mIG9uZ29pbmdTY29wZXNcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gc2NvcGVzXHJcbiAgICAgKiBAcGFyYW0gb25nb2luZ1Njb3Blc1xyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgYXJlUmVhZHkoc2NvcGVzOiBzdHJpbmdbXSwgb25nb2luZ1Njb3Blczogc3RyaW5nW10pOiBib29sZWFuO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVjayBpZiB0d28gc2NvcGVzIG92ZXJsYXAuXHJcbiAgICAgKlxyXG4gICAgICogRXhhbXBsZSBvZiBzY29wZXMgdGhhdCBvdmVybGFwOlxyXG4gICAgICogJ3Rlc3QnIGFuZCAndGVzdCcsICd0ZXN0LmEnIGFuZCAndGVzdCcsICd0ZXN0JyBhbmQgJ3Rlc3QuYSdcclxuICAgICAqXHJcbiAgICAgKiBFeGFtcGxlIG9mIHNjb3BlcyB0aGF0IGRvIG5vdCBvdmVybGFwOlxyXG4gICAgICogJ3Rlc3QnIGFuZCAndGVzdEEnLCAndGVzdC5hJyBhbmQgJ3Rlc3QuYicsICd0ZXN0Lm5lc3RlZCcgYW5kICd0ZXN0Lm5lc3QnXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGEgU2NvcGVBXHJcbiAgICAgKiBAcGFyYW0gYiBTY29wZUJcclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIHNjb3Blc092ZXJsYXAoYTogc3RyaW5nLCBiOiBzdHJpbmcpOiBib29sZWFuO1xyXG59XHJcbiJdfQ==