import { ScopedData } from '../../model/scoped-data';
import { HttpClient } from '@angular/common/http';
import * as ɵngcc0 from '@angular/core';
export interface ScopedDataWithUrl {
    /** Url (with fields) to load scoped data */
    url?: string;
    /** scoped data model */
    scopedData: ScopedData<any>;
}
/**
 * Intermediate model to accommodate all data needed to perform occ fields optimizations
 * wrapping ScopedData with url and fields
 */
export interface OccFieldsModel extends ScopedDataWithUrl {
    /** extracted fields object, used to extract data from broader model */
    fields?: object;
}
/**
 * Grouped rest calls with optimal urls
 *
 * One url groups all scopes it covers with related occFieldsModels
 */
export interface OccOptimimalUrlGroups {
    [optimalUrl: string]: {
        [scope: string]: OccFieldsModel;
    };
}
/**
 * Helper service for optimizing endpoint calls to occ backend
 */
export declare class OccFieldsService {
    protected http: HttpClient;
    constructor(http: HttpClient);
    protected FIELDS_PARAM: string;
    /**
     * Merge similar occ endpoints calls by merging fields parameter
     *
     * We assume that different scopes are defined by different fields parameters,
     * so we are grouping all requests with the same urls (except fields definition)
     * and merging into one request with fields that will satisfy all separate ones.
     *
     * @param models
     */
    getOptimalUrlGroups(models: ScopedDataWithUrl[]): OccOptimimalUrlGroups;
    /**
     * Extract fields parameter from occ endpoint url
     *
     * @param urlWithFields
     */
    private splitFields;
    /**
     * Combine url with field parameters
     *
     * @param url
     * @param fields
     */
    private getUrlWithFields;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<OccFieldsService, never>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoib2NjLWZpZWxkcy5zZXJ2aWNlLmQudHMiLCJzb3VyY2VzIjpbIm9jYy1maWVsZHMuc2VydmljZS5kLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgU2NvcGVkRGF0YSB9IGZyb20gJy4uLy4uL21vZGVsL3Njb3BlZC1kYXRhJztcclxuaW1wb3J0IHsgSHR0cENsaWVudCB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbi9odHRwJztcclxuZXhwb3J0IGludGVyZmFjZSBTY29wZWREYXRhV2l0aFVybCB7XHJcbiAgICAvKiogVXJsICh3aXRoIGZpZWxkcykgdG8gbG9hZCBzY29wZWQgZGF0YSAqL1xyXG4gICAgdXJsPzogc3RyaW5nO1xyXG4gICAgLyoqIHNjb3BlZCBkYXRhIG1vZGVsICovXHJcbiAgICBzY29wZWREYXRhOiBTY29wZWREYXRhPGFueT47XHJcbn1cclxuLyoqXHJcbiAqIEludGVybWVkaWF0ZSBtb2RlbCB0byBhY2NvbW1vZGF0ZSBhbGwgZGF0YSBuZWVkZWQgdG8gcGVyZm9ybSBvY2MgZmllbGRzIG9wdGltaXphdGlvbnNcclxuICogd3JhcHBpbmcgU2NvcGVkRGF0YSB3aXRoIHVybCBhbmQgZmllbGRzXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIE9jY0ZpZWxkc01vZGVsIGV4dGVuZHMgU2NvcGVkRGF0YVdpdGhVcmwge1xyXG4gICAgLyoqIGV4dHJhY3RlZCBmaWVsZHMgb2JqZWN0LCB1c2VkIHRvIGV4dHJhY3QgZGF0YSBmcm9tIGJyb2FkZXIgbW9kZWwgKi9cclxuICAgIGZpZWxkcz86IG9iamVjdDtcclxufVxyXG4vKipcclxuICogR3JvdXBlZCByZXN0IGNhbGxzIHdpdGggb3B0aW1hbCB1cmxzXHJcbiAqXHJcbiAqIE9uZSB1cmwgZ3JvdXBzIGFsbCBzY29wZXMgaXQgY292ZXJzIHdpdGggcmVsYXRlZCBvY2NGaWVsZHNNb2RlbHNcclxuICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgT2NjT3B0aW1pbWFsVXJsR3JvdXBzIHtcclxuICAgIFtvcHRpbWFsVXJsOiBzdHJpbmddOiB7XHJcbiAgICAgICAgW3Njb3BlOiBzdHJpbmddOiBPY2NGaWVsZHNNb2RlbDtcclxuICAgIH07XHJcbn1cclxuLyoqXHJcbiAqIEhlbHBlciBzZXJ2aWNlIGZvciBvcHRpbWl6aW5nIGVuZHBvaW50IGNhbGxzIHRvIG9jYyBiYWNrZW5kXHJcbiAqL1xyXG5leHBvcnQgZGVjbGFyZSBjbGFzcyBPY2NGaWVsZHNTZXJ2aWNlIHtcclxuICAgIHByb3RlY3RlZCBodHRwOiBIdHRwQ2xpZW50O1xyXG4gICAgY29uc3RydWN0b3IoaHR0cDogSHR0cENsaWVudCk7XHJcbiAgICBwcm90ZWN0ZWQgRklFTERTX1BBUkFNOiBzdHJpbmc7XHJcbiAgICAvKipcclxuICAgICAqIE1lcmdlIHNpbWlsYXIgb2NjIGVuZHBvaW50cyBjYWxscyBieSBtZXJnaW5nIGZpZWxkcyBwYXJhbWV0ZXJcclxuICAgICAqXHJcbiAgICAgKiBXZSBhc3N1bWUgdGhhdCBkaWZmZXJlbnQgc2NvcGVzIGFyZSBkZWZpbmVkIGJ5IGRpZmZlcmVudCBmaWVsZHMgcGFyYW1ldGVycyxcclxuICAgICAqIHNvIHdlIGFyZSBncm91cGluZyBhbGwgcmVxdWVzdHMgd2l0aCB0aGUgc2FtZSB1cmxzIChleGNlcHQgZmllbGRzIGRlZmluaXRpb24pXHJcbiAgICAgKiBhbmQgbWVyZ2luZyBpbnRvIG9uZSByZXF1ZXN0IHdpdGggZmllbGRzIHRoYXQgd2lsbCBzYXRpc2Z5IGFsbCBzZXBhcmF0ZSBvbmVzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBtb2RlbHNcclxuICAgICAqL1xyXG4gICAgZ2V0T3B0aW1hbFVybEdyb3Vwcyhtb2RlbHM6IFNjb3BlZERhdGFXaXRoVXJsW10pOiBPY2NPcHRpbWltYWxVcmxHcm91cHM7XHJcbiAgICAvKipcclxuICAgICAqIEV4dHJhY3QgZmllbGRzIHBhcmFtZXRlciBmcm9tIG9jYyBlbmRwb2ludCB1cmxcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdXJsV2l0aEZpZWxkc1xyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHNwbGl0RmllbGRzO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDb21iaW5lIHVybCB3aXRoIGZpZWxkIHBhcmFtZXRlcnNcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdXJsXHJcbiAgICAgKiBAcGFyYW0gZmllbGRzXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgZ2V0VXJsV2l0aEZpZWxkcztcclxufVxyXG4iXX0=