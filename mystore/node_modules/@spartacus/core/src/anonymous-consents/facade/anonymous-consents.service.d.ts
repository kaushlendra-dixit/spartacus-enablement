import { Store } from '@ngrx/store';
import { Observable } from 'rxjs';
import { AuthService } from '../../auth/index';
import { AnonymousConsent, ConsentTemplate } from '../../model/index';
import { StateWithAnonymousConsents } from '../store/anonymous-consents-state';
import * as ɵngcc0 from '@angular/core';
export declare class AnonymousConsentsService {
    protected store: Store<StateWithAnonymousConsents>;
    protected authService: AuthService;
    constructor(store: Store<StateWithAnonymousConsents>, authService: AuthService);
    /**
     * Retrieves the anonymous consent templates.
     */
    loadTemplates(): void;
    /**
     * Conditionally triggers the load of the anonymous consent templates if:
     *   - `loadIfMissing` parameter is set to `true`
     *   - the `templates` in the store are `undefined`
     *
     * Othewise it just returns the value from the store.
     *
     * @param loadIfMissing setting to `true` will trigger the load of the templates if the currently stored templates are `undefined`
     */
    getTemplates(loadIfMissing?: boolean): Observable<ConsentTemplate[]>;
    /**
     * Returns the anonymous consent templates with the given template code.
     * @param templateCode a template code by which to filter anonymous consent templates.
     */
    getTemplate(templateCode: string): Observable<ConsentTemplate>;
    /**
     * Returns an indicator for the loading status for the anonymous consent templates.
     */
    getLoadTemplatesLoading(): Observable<boolean>;
    /**
     * Returns an indicator for the success status for the anonymous consent templates.
     */
    getLoadTemplatesSuccess(): Observable<boolean>;
    /**
     * Returns an indicator for the error status for the anonymous consent templates.
     */
    getLoadTemplatesError(): Observable<boolean>;
    /**
     * Resets the loading, success and error indicators for the anonymous consent templates.
     */
    resetLoadTemplatesState(): void;
    /**
     * Returns all the anonymous consents.
     */
    getConsents(): Observable<AnonymousConsent[]>;
    /**
     * Puts the provided anonymous consents into the store.
     */
    setConsents(consents: AnonymousConsent[]): void;
    /**
     * Returns the anonymous consent for the given template ID.
     *
     * As a side-effect, the method will call `getTemplates(true)` to load the templates if those are not present.
     *
     * @param templateId a template ID by which to filter anonymous consent templates.
     */
    getConsent(templateId: string): Observable<AnonymousConsent>;
    /**
     * Give a consent for the given `templateCode`
     * @param templateCode for which to give the consent
     */
    giveConsent(templateCode: string): void;
    /**
     * Sets all the anonymous consents' state to given.
     */
    giveAllConsents(): Observable<ConsentTemplate[]>;
    /**
     * Returns `true` if the provided `consent` is given.
     * @param consent a consent to test
     */
    isConsentGiven(consent: AnonymousConsent): boolean;
    /**
     * Withdraw a consent for the given `templateCode`
     * @param templateCode for which to withdraw the consent
     */
    withdrawConsent(templateCode: string): void;
    /**
     * Sets all the anonymous consents' state to withdrawn.
     */
    withdrawAllConsents(): Observable<ConsentTemplate[]>;
    /**
     * Returns `true` if the provided `consent` is withdrawn.
     * @param consent a consent to test
     */
    isConsentWithdrawn(consent: AnonymousConsent): boolean;
    /**
     * Toggles the dismissed state of the anonymous consents banner.
     * @param dismissed the banner will be dismissed if `true` is passed, otherwise it will be visible.
     */
    toggleBannerDismissed(dismissed: boolean): void;
    /**
     * Returns `true` if the banner was dismissed, `false` otherwise.
     */
    isBannerDismissed(): Observable<boolean>;
    /**
     * Returns `true` if the consent templates were updated on the back-end.
     * If the templates are not present in the store, it triggers the load.
     */
    getTemplatesUpdated(): Observable<boolean>;
    /**
     * Toggles the `updated` slice of the state
     * @param updated
     */
    toggleTemplatesUpdated(updated: boolean): void;
    /**
     * Returns `true` if either the banner is not dismissed or if the templates were updated on the back-end.
     * Otherwise, it returns `false`.
     */
    isBannerVisible(): Observable<boolean>;
    /**
     * Dispatches an action to trigger the check
     * whether the anonymous consent version have been updated
     */
    private checkConsentVersions;
    /**
     * Returns `true` if there's a missmatch in template versions between the provided `currentTemplates` and `newTemplates`
     * @param currentTemplates current templates to check
     * @param newTemplates new templates to check
     */
    detectUpdatedTemplates(currentTemplates: ConsentTemplate[], newTemplates: ConsentTemplate[]): boolean;
    /**
     * Serializes using `JSON.stringify()` and encodes using `encodeURIComponent()` methods
     * @param consents to serialize and encode
     */
    serializeAndEncode(consents: AnonymousConsent[]): string;
    /**
     * Decodes using `decodeURIComponent()` and deserializes using `JSON.parse()`
     * @param rawConsents to decode an deserialize
     */
    decodeAndDeserialize(rawConsents: string): AnonymousConsent[];
    /**
     *
     * Compares the given `newConsents` and `previousConsents` and returns `true` if there are differences (the `newConsents` are updates).
     * Otherwise it returns `false`.
     *
     * @param newConsents new consents to compare
     * @param previousConsents old consents to compare
     */
    consentsUpdated(newConsents: AnonymousConsent[], previousConsents: AnonymousConsent[]): boolean;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<AnonymousConsentsService, never>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYW5vbnltb3VzLWNvbnNlbnRzLnNlcnZpY2UuZC50cyIsInNvdXJjZXMiOlsiYW5vbnltb3VzLWNvbnNlbnRzLnNlcnZpY2UuZC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0EiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBTdG9yZSB9IGZyb20gJ0BuZ3J4L3N0b3JlJztcclxuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMnO1xyXG5pbXBvcnQgeyBBdXRoU2VydmljZSB9IGZyb20gJy4uLy4uL2F1dGgvaW5kZXgnO1xyXG5pbXBvcnQgeyBBbm9ueW1vdXNDb25zZW50LCBDb25zZW50VGVtcGxhdGUgfSBmcm9tICcuLi8uLi9tb2RlbC9pbmRleCc7XHJcbmltcG9ydCB7IFN0YXRlV2l0aEFub255bW91c0NvbnNlbnRzIH0gZnJvbSAnLi4vc3RvcmUvYW5vbnltb3VzLWNvbnNlbnRzLXN0YXRlJztcclxuZXhwb3J0IGRlY2xhcmUgY2xhc3MgQW5vbnltb3VzQ29uc2VudHNTZXJ2aWNlIHtcclxuICAgIHByb3RlY3RlZCBzdG9yZTogU3RvcmU8U3RhdGVXaXRoQW5vbnltb3VzQ29uc2VudHM+O1xyXG4gICAgcHJvdGVjdGVkIGF1dGhTZXJ2aWNlOiBBdXRoU2VydmljZTtcclxuICAgIGNvbnN0cnVjdG9yKHN0b3JlOiBTdG9yZTxTdGF0ZVdpdGhBbm9ueW1vdXNDb25zZW50cz4sIGF1dGhTZXJ2aWNlOiBBdXRoU2VydmljZSk7XHJcbiAgICAvKipcclxuICAgICAqIFJldHJpZXZlcyB0aGUgYW5vbnltb3VzIGNvbnNlbnQgdGVtcGxhdGVzLlxyXG4gICAgICovXHJcbiAgICBsb2FkVGVtcGxhdGVzKCk6IHZvaWQ7XHJcbiAgICAvKipcclxuICAgICAqIENvbmRpdGlvbmFsbHkgdHJpZ2dlcnMgdGhlIGxvYWQgb2YgdGhlIGFub255bW91cyBjb25zZW50IHRlbXBsYXRlcyBpZjpcclxuICAgICAqICAgLSBgbG9hZElmTWlzc2luZ2AgcGFyYW1ldGVyIGlzIHNldCB0byBgdHJ1ZWBcclxuICAgICAqICAgLSB0aGUgYHRlbXBsYXRlc2AgaW4gdGhlIHN0b3JlIGFyZSBgdW5kZWZpbmVkYFxyXG4gICAgICpcclxuICAgICAqIE90aGV3aXNlIGl0IGp1c3QgcmV0dXJucyB0aGUgdmFsdWUgZnJvbSB0aGUgc3RvcmUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGxvYWRJZk1pc3Npbmcgc2V0dGluZyB0byBgdHJ1ZWAgd2lsbCB0cmlnZ2VyIHRoZSBsb2FkIG9mIHRoZSB0ZW1wbGF0ZXMgaWYgdGhlIGN1cnJlbnRseSBzdG9yZWQgdGVtcGxhdGVzIGFyZSBgdW5kZWZpbmVkYFxyXG4gICAgICovXHJcbiAgICBnZXRUZW1wbGF0ZXMobG9hZElmTWlzc2luZz86IGJvb2xlYW4pOiBPYnNlcnZhYmxlPENvbnNlbnRUZW1wbGF0ZVtdPjtcclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgYW5vbnltb3VzIGNvbnNlbnQgdGVtcGxhdGVzIHdpdGggdGhlIGdpdmVuIHRlbXBsYXRlIGNvZGUuXHJcbiAgICAgKiBAcGFyYW0gdGVtcGxhdGVDb2RlIGEgdGVtcGxhdGUgY29kZSBieSB3aGljaCB0byBmaWx0ZXIgYW5vbnltb3VzIGNvbnNlbnQgdGVtcGxhdGVzLlxyXG4gICAgICovXHJcbiAgICBnZXRUZW1wbGF0ZSh0ZW1wbGF0ZUNvZGU6IHN0cmluZyk6IE9ic2VydmFibGU8Q29uc2VudFRlbXBsYXRlPjtcclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhbiBpbmRpY2F0b3IgZm9yIHRoZSBsb2FkaW5nIHN0YXR1cyBmb3IgdGhlIGFub255bW91cyBjb25zZW50IHRlbXBsYXRlcy5cclxuICAgICAqL1xyXG4gICAgZ2V0TG9hZFRlbXBsYXRlc0xvYWRpbmcoKTogT2JzZXJ2YWJsZTxib29sZWFuPjtcclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhbiBpbmRpY2F0b3IgZm9yIHRoZSBzdWNjZXNzIHN0YXR1cyBmb3IgdGhlIGFub255bW91cyBjb25zZW50IHRlbXBsYXRlcy5cclxuICAgICAqL1xyXG4gICAgZ2V0TG9hZFRlbXBsYXRlc1N1Y2Nlc3MoKTogT2JzZXJ2YWJsZTxib29sZWFuPjtcclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhbiBpbmRpY2F0b3IgZm9yIHRoZSBlcnJvciBzdGF0dXMgZm9yIHRoZSBhbm9ueW1vdXMgY29uc2VudCB0ZW1wbGF0ZXMuXHJcbiAgICAgKi9cclxuICAgIGdldExvYWRUZW1wbGF0ZXNFcnJvcigpOiBPYnNlcnZhYmxlPGJvb2xlYW4+O1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXNldHMgdGhlIGxvYWRpbmcsIHN1Y2Nlc3MgYW5kIGVycm9yIGluZGljYXRvcnMgZm9yIHRoZSBhbm9ueW1vdXMgY29uc2VudCB0ZW1wbGF0ZXMuXHJcbiAgICAgKi9cclxuICAgIHJlc2V0TG9hZFRlbXBsYXRlc1N0YXRlKCk6IHZvaWQ7XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYWxsIHRoZSBhbm9ueW1vdXMgY29uc2VudHMuXHJcbiAgICAgKi9cclxuICAgIGdldENvbnNlbnRzKCk6IE9ic2VydmFibGU8QW5vbnltb3VzQ29uc2VudFtdPjtcclxuICAgIC8qKlxyXG4gICAgICogUHV0cyB0aGUgcHJvdmlkZWQgYW5vbnltb3VzIGNvbnNlbnRzIGludG8gdGhlIHN0b3JlLlxyXG4gICAgICovXHJcbiAgICBzZXRDb25zZW50cyhjb25zZW50czogQW5vbnltb3VzQ29uc2VudFtdKTogdm9pZDtcclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgYW5vbnltb3VzIGNvbnNlbnQgZm9yIHRoZSBnaXZlbiB0ZW1wbGF0ZSBJRC5cclxuICAgICAqXHJcbiAgICAgKiBBcyBhIHNpZGUtZWZmZWN0LCB0aGUgbWV0aG9kIHdpbGwgY2FsbCBgZ2V0VGVtcGxhdGVzKHRydWUpYCB0byBsb2FkIHRoZSB0ZW1wbGF0ZXMgaWYgdGhvc2UgYXJlIG5vdCBwcmVzZW50LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB0ZW1wbGF0ZUlkIGEgdGVtcGxhdGUgSUQgYnkgd2hpY2ggdG8gZmlsdGVyIGFub255bW91cyBjb25zZW50IHRlbXBsYXRlcy5cclxuICAgICAqL1xyXG4gICAgZ2V0Q29uc2VudCh0ZW1wbGF0ZUlkOiBzdHJpbmcpOiBPYnNlcnZhYmxlPEFub255bW91c0NvbnNlbnQ+O1xyXG4gICAgLyoqXHJcbiAgICAgKiBHaXZlIGEgY29uc2VudCBmb3IgdGhlIGdpdmVuIGB0ZW1wbGF0ZUNvZGVgXHJcbiAgICAgKiBAcGFyYW0gdGVtcGxhdGVDb2RlIGZvciB3aGljaCB0byBnaXZlIHRoZSBjb25zZW50XHJcbiAgICAgKi9cclxuICAgIGdpdmVDb25zZW50KHRlbXBsYXRlQ29kZTogc3RyaW5nKTogdm9pZDtcclxuICAgIC8qKlxyXG4gICAgICogU2V0cyBhbGwgdGhlIGFub255bW91cyBjb25zZW50cycgc3RhdGUgdG8gZ2l2ZW4uXHJcbiAgICAgKi9cclxuICAgIGdpdmVBbGxDb25zZW50cygpOiBPYnNlcnZhYmxlPENvbnNlbnRUZW1wbGF0ZVtdPjtcclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHByb3ZpZGVkIGBjb25zZW50YCBpcyBnaXZlbi5cclxuICAgICAqIEBwYXJhbSBjb25zZW50IGEgY29uc2VudCB0byB0ZXN0XHJcbiAgICAgKi9cclxuICAgIGlzQ29uc2VudEdpdmVuKGNvbnNlbnQ6IEFub255bW91c0NvbnNlbnQpOiBib29sZWFuO1xyXG4gICAgLyoqXHJcbiAgICAgKiBXaXRoZHJhdyBhIGNvbnNlbnQgZm9yIHRoZSBnaXZlbiBgdGVtcGxhdGVDb2RlYFxyXG4gICAgICogQHBhcmFtIHRlbXBsYXRlQ29kZSBmb3Igd2hpY2ggdG8gd2l0aGRyYXcgdGhlIGNvbnNlbnRcclxuICAgICAqL1xyXG4gICAgd2l0aGRyYXdDb25zZW50KHRlbXBsYXRlQ29kZTogc3RyaW5nKTogdm9pZDtcclxuICAgIC8qKlxyXG4gICAgICogU2V0cyBhbGwgdGhlIGFub255bW91cyBjb25zZW50cycgc3RhdGUgdG8gd2l0aGRyYXduLlxyXG4gICAgICovXHJcbiAgICB3aXRoZHJhd0FsbENvbnNlbnRzKCk6IE9ic2VydmFibGU8Q29uc2VudFRlbXBsYXRlW10+O1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcHJvdmlkZWQgYGNvbnNlbnRgIGlzIHdpdGhkcmF3bi5cclxuICAgICAqIEBwYXJhbSBjb25zZW50IGEgY29uc2VudCB0byB0ZXN0XHJcbiAgICAgKi9cclxuICAgIGlzQ29uc2VudFdpdGhkcmF3bihjb25zZW50OiBBbm9ueW1vdXNDb25zZW50KTogYm9vbGVhbjtcclxuICAgIC8qKlxyXG4gICAgICogVG9nZ2xlcyB0aGUgZGlzbWlzc2VkIHN0YXRlIG9mIHRoZSBhbm9ueW1vdXMgY29uc2VudHMgYmFubmVyLlxyXG4gICAgICogQHBhcmFtIGRpc21pc3NlZCB0aGUgYmFubmVyIHdpbGwgYmUgZGlzbWlzc2VkIGlmIGB0cnVlYCBpcyBwYXNzZWQsIG90aGVyd2lzZSBpdCB3aWxsIGJlIHZpc2libGUuXHJcbiAgICAgKi9cclxuICAgIHRvZ2dsZUJhbm5lckRpc21pc3NlZChkaXNtaXNzZWQ6IGJvb2xlYW4pOiB2b2lkO1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYmFubmVyIHdhcyBkaXNtaXNzZWQsIGBmYWxzZWAgb3RoZXJ3aXNlLlxyXG4gICAgICovXHJcbiAgICBpc0Jhbm5lckRpc21pc3NlZCgpOiBPYnNlcnZhYmxlPGJvb2xlYW4+O1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgY29uc2VudCB0ZW1wbGF0ZXMgd2VyZSB1cGRhdGVkIG9uIHRoZSBiYWNrLWVuZC5cclxuICAgICAqIElmIHRoZSB0ZW1wbGF0ZXMgYXJlIG5vdCBwcmVzZW50IGluIHRoZSBzdG9yZSwgaXQgdHJpZ2dlcnMgdGhlIGxvYWQuXHJcbiAgICAgKi9cclxuICAgIGdldFRlbXBsYXRlc1VwZGF0ZWQoKTogT2JzZXJ2YWJsZTxib29sZWFuPjtcclxuICAgIC8qKlxyXG4gICAgICogVG9nZ2xlcyB0aGUgYHVwZGF0ZWRgIHNsaWNlIG9mIHRoZSBzdGF0ZVxyXG4gICAgICogQHBhcmFtIHVwZGF0ZWRcclxuICAgICAqL1xyXG4gICAgdG9nZ2xlVGVtcGxhdGVzVXBkYXRlZCh1cGRhdGVkOiBib29sZWFuKTogdm9pZDtcclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBgdHJ1ZWAgaWYgZWl0aGVyIHRoZSBiYW5uZXIgaXMgbm90IGRpc21pc3NlZCBvciBpZiB0aGUgdGVtcGxhdGVzIHdlcmUgdXBkYXRlZCBvbiB0aGUgYmFjay1lbmQuXHJcbiAgICAgKiBPdGhlcndpc2UsIGl0IHJldHVybnMgYGZhbHNlYC5cclxuICAgICAqL1xyXG4gICAgaXNCYW5uZXJWaXNpYmxlKCk6IE9ic2VydmFibGU8Ym9vbGVhbj47XHJcbiAgICAvKipcclxuICAgICAqIERpc3BhdGNoZXMgYW4gYWN0aW9uIHRvIHRyaWdnZXIgdGhlIGNoZWNrXHJcbiAgICAgKiB3aGV0aGVyIHRoZSBhbm9ueW1vdXMgY29uc2VudCB2ZXJzaW9uIGhhdmUgYmVlbiB1cGRhdGVkXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgY2hlY2tDb25zZW50VmVyc2lvbnM7XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYHRydWVgIGlmIHRoZXJlJ3MgYSBtaXNzbWF0Y2ggaW4gdGVtcGxhdGUgdmVyc2lvbnMgYmV0d2VlbiB0aGUgcHJvdmlkZWQgYGN1cnJlbnRUZW1wbGF0ZXNgIGFuZCBgbmV3VGVtcGxhdGVzYFxyXG4gICAgICogQHBhcmFtIGN1cnJlbnRUZW1wbGF0ZXMgY3VycmVudCB0ZW1wbGF0ZXMgdG8gY2hlY2tcclxuICAgICAqIEBwYXJhbSBuZXdUZW1wbGF0ZXMgbmV3IHRlbXBsYXRlcyB0byBjaGVja1xyXG4gICAgICovXHJcbiAgICBkZXRlY3RVcGRhdGVkVGVtcGxhdGVzKGN1cnJlbnRUZW1wbGF0ZXM6IENvbnNlbnRUZW1wbGF0ZVtdLCBuZXdUZW1wbGF0ZXM6IENvbnNlbnRUZW1wbGF0ZVtdKTogYm9vbGVhbjtcclxuICAgIC8qKlxyXG4gICAgICogU2VyaWFsaXplcyB1c2luZyBgSlNPTi5zdHJpbmdpZnkoKWAgYW5kIGVuY29kZXMgdXNpbmcgYGVuY29kZVVSSUNvbXBvbmVudCgpYCBtZXRob2RzXHJcbiAgICAgKiBAcGFyYW0gY29uc2VudHMgdG8gc2VyaWFsaXplIGFuZCBlbmNvZGVcclxuICAgICAqL1xyXG4gICAgc2VyaWFsaXplQW5kRW5jb2RlKGNvbnNlbnRzOiBBbm9ueW1vdXNDb25zZW50W10pOiBzdHJpbmc7XHJcbiAgICAvKipcclxuICAgICAqIERlY29kZXMgdXNpbmcgYGRlY29kZVVSSUNvbXBvbmVudCgpYCBhbmQgZGVzZXJpYWxpemVzIHVzaW5nIGBKU09OLnBhcnNlKClgXHJcbiAgICAgKiBAcGFyYW0gcmF3Q29uc2VudHMgdG8gZGVjb2RlIGFuIGRlc2VyaWFsaXplXHJcbiAgICAgKi9cclxuICAgIGRlY29kZUFuZERlc2VyaWFsaXplKHJhd0NvbnNlbnRzOiBzdHJpbmcpOiBBbm9ueW1vdXNDb25zZW50W107XHJcbiAgICAvKipcclxuICAgICAqXHJcbiAgICAgKiBDb21wYXJlcyB0aGUgZ2l2ZW4gYG5ld0NvbnNlbnRzYCBhbmQgYHByZXZpb3VzQ29uc2VudHNgIGFuZCByZXR1cm5zIGB0cnVlYCBpZiB0aGVyZSBhcmUgZGlmZmVyZW5jZXMgKHRoZSBgbmV3Q29uc2VudHNgIGFyZSB1cGRhdGVzKS5cclxuICAgICAqIE90aGVyd2lzZSBpdCByZXR1cm5zIGBmYWxzZWAuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIG5ld0NvbnNlbnRzIG5ldyBjb25zZW50cyB0byBjb21wYXJlXHJcbiAgICAgKiBAcGFyYW0gcHJldmlvdXNDb25zZW50cyBvbGQgY29uc2VudHMgdG8gY29tcGFyZVxyXG4gICAgICovXHJcbiAgICBjb25zZW50c1VwZGF0ZWQobmV3Q29uc2VudHM6IEFub255bW91c0NvbnNlbnRbXSwgcHJldmlvdXNDb25zZW50czogQW5vbnltb3VzQ29uc2VudFtdKTogYm9vbGVhbjtcclxufVxyXG4iXX0=